#-------------------- Imports --------------------

from bs4 import BeautifulSoup as bs
from urllib.parse import urljoin
from pprint import pprint
import time
import requests
import csv
from colorama import init, Fore

# Initialize colorama for autoreset
init(autoreset=True)

#-------------------- Time management  --------------------

def format_time(seconds):
    minutes = seconds // 60
    remaining_seconds = seconds % 60
    return f"{int(minutes)} minutes and {int(remaining_seconds)} seconds"

#-------------------- Connections --------------------

# Establishing an HTTP session and configuring the browser user agent
session = requests.Session()
session.headers["User-Agent"] = (
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
    "AppleWebKit/605.1.15 (KHTML, like Gecko) "
    "Version/17.1.2 Safari/605.1.15"
)

# Extracting all forms from the specified url, retrieving all forms from the HTML content
def retrieve_all_forms(url):
    soup = bs(session.get(url).content, "html.parser")
    return soup.find_all("form")

# This function retrieves all relevant information from forms
def retrieve_form_details(form):
    details = {}
    # Retrieve the target URL of the form action
    try:
        action = form.attrs.get("action").lower()
    except:
        action = None
    # Retrieve the form method (e.g., POST, GET)
    method = form.attrs.get("method", "get").lower()
    # Retrieve details of all input elements including their types and names
    inputs = []
    for input__Tag in form.find_all("input"):
        input_name = input__Tag.attrs.get("name")
        input_value = input__Tag.attrs.get("value", "")
        input_type = input__Tag.attrs.get("type", "text")
        inputs.append({"type": input_type, "name": input_name, "value": input_value})
    # Store all extracted details into the resulting dictionary
    details["method"] = method
    details["inputs"] = inputs
    details["action"] = action
    
    return details

#-------------------- Code for scanning for CSS vulnerabilities --------------------

# CSV file path for CSS vulnerabilities
CSS_CSV_FILE_PATH = "css_scan_log.csv"

def log_css_vulnerability(url, form_details, payload):
    """
    Log the detected CSS vulnerability into a CSV file.
    
    Parameters:
    - url (str): The URL where the vulnerability was detected.
    - form_details (dict): Details of the vulnerable HTML form.
    - payload (str): The payload used to trigger the vulnerability.
    """
    with open(CSS_CSV_FILE_PATH, mode='a', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(["CSS Vulnerability Detected"])
        writer.writerow(["URL", url])
        writer.writerow(["Payload", payload])
        if form_details:
            writer.writerow(["Form Details"])
            for key, value in form_details.items():
                writer.writerow([key, value])
        else:
            # Indicate that no form details were available
            writer.writerow(["Form Details", "N/A, CSS vulnerability was detected directly in the URL without form submission"])
        writer.writerow([])  # Add an empty row for better readability

def retrieve_form(form_details, url, value):
    """
    Parameters:
    form_details (list): A dictionary containing form information.
    url (str): The original URL with the form.
    value (str): The value to replace text and search inputs.
    Returns:
    HTTP Response after form submission.
    """
    # Build the complete URL
    target_url = urljoin(url, form_details["action"])
    
    # Retrieve the inputs
    inputs = form_details["inputs"]
    data = {}
    for input in inputs:
        # Substitute all text and search values with the specified value
        if input["type"] == "text" or input["type"] == "search":
            input["value"] = value
        input_name = input.get("name")
        input_value = input.get("value")
        if input_name and input_value:
            # Include inputs with both name and value
            data[input_name] = input_value

    print(Fore.GREEN + "[•] Sending potential harmful payload to", end=" ")
    print(Fore.RESET + target_url)
    print(Fore.GREEN + "[•] Data:", end=" ")
    print(Fore.RESET + str(data))

    if form_details["method"] == "post":
        return requests.post(target_url, data=data)
    else:
        # HTTP GET request
        return requests.get(target_url, params=data)


def CSS_Scan(url):
    start_time = time.time()  # Start the timer

    try:
        # Fetch all forms from the provided URL
        f = open('CSS_Payload.txt', encoding="utf8")
        payloads = f.read().splitlines()

        forms = retrieve_all_forms(url)
        if not forms:
            # Return if no forms found
            print(Fore.RED + "Unable to read the URL. Please provide a valid URL.")
            return False
        
        print(Fore.GREEN + "[•] Identified ", end="")
        print(f"{len(forms)} forms on {url}.")

        has_vulnerability = False
        
        # Iterate through all forms and payloads
        for form in forms:
            form_details = retrieve_form_details(form)
            for payload in payloads:
                content = retrieve_form(form_details, url, payload).content.decode()
                
                # Check if payload triggers vulnerability
                if payload in content:
                    print(Fore.RED + f"[Obs!] CSS Identified on {url}")
                    print(Fore.RED + f"[•] Form details:")
                    print(form_details)
                    has_vulnerability = True

                    # Log the vulnerability
                    log_css_vulnerability(url, form_details, payload)
        
        return has_vulnerability

    except Exception as e:
        print(Fore.RED + "An error occurred while scanning the URL:", e)
        return False
    finally:
        # Stop the timer
        end_time = time.time()
        
        # Calculate the duration
        duration = end_time - start_time
        
        # Display the completion time
        if duration > 60:
            duration_str = format_time(duration)
            print(Fore.GREEN + f"CSS Scan completed in {duration_str}.")
        else:
            print(Fore.GREEN + f"CSS Scan completed in {duration:.2f} seconds.")

#-------------------- Code for scanning for SQLI vulnerabilities --------------------

# An elementary boolean function assessing whether a webpage,
# is susceptible to SQL Injection based on its content
def has_vulnerability(content):
    errors = {
        # SQL Server
        "unclosed quotation mark after the character string",
        # Oracle
        "quoted string not properly terminated",
        # MySQL
        "you have an error in your sql syntax;",
        "warning: mysql",
        # Postgres
        "syntax error at or near",
        "pgsql_query",
        # SQLite
        "syntax error",
        "sqlite3",  
    }
    for error in errors:
        # Error detection flag, Error
        if error in content.content.decode().lower():
            return True
    # Validation successful, No error
    return False

# CSV file path
CSV_FILE_PATH = "sqli_scan_log.csv"

def log_vulnerability(url, form_details):
    """
    Log the detected SQL injection vulnerability into a CSV file.
    
    Parameters:
    - url (str): The URL where the vulnerability was detected.
    - form_details (dict): Details of the vulnerable HTML form.
    """
    with open(CSV_FILE_PATH, mode='a', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(["SQL Injection Vulnerability Detected"])
        writer.writerow(["URL", url])
        if form_details:
            writer.writerow(["Form Details"])
            for key, value in form_details.items():
                writer.writerow([key, value])
        else:
            # Indicate that no form details were available
            writer.writerow(["Form Details", "N/A, SQL injection was detected directly in the URL without form submission"])
        writer.writerow([])  # Add an empty row for better readability

"""
    Function to scan a URL for input fields and attempt to insert,
    both single and double quote characters.
"""
def SQLI_Scan(URL):
    start_time = time.time()  # Start the timer

    # URL testing phase
    f = open('SQLI_Payload.txt', 'r')
    payloads = f.read().splitlines()

    try:
        for j in payloads:
            # URL with quote/double quote characters added for testing
            URL = f"{URL}{j}"
            print(Fore.GREEN + "[•] Running Test", URL)


            # Perform HTTP request
            res = session.get(URL)
            if has_vulnerability(res):
                """
                SQL Injection detected in the URL itself,
                no need to proceed with form extraction and submission´
                """
                print(Fore.RED + "[Obs!] SQL Injection vulnerability identified, The link:", URL)
                log_vulnerability(URL, {})  # Log the URL without form details
                

        # Testing phase initiated for HTML forms
        forms = retrieve_all_forms(URL)
        if not forms:
            # Return to main function if URL couldn't be read
            print(Fore.RED + "No forms found, SQL Injection Scanned only in the URL itself.")
            return
        
        print(Fore.GREEN + "[•] Identified ", end="")
        print(f"{len(forms)} forms on {URL}.")

        for form in forms:
            form_details = retrieve_form_details(form)
            for j in payloads:
                # Data body to be submitted
                data = {}
                for input_tag in form_details["inputs"]:
                    if input_tag["value"] or input_tag["type"] == "hidden":
                        # Use any input form with a value or hidden attribute in the form body
                        try:
                            data[input_tag["name"]] = input_tag["value"] + j
                        except:
                            pass
                    elif input_tag["type"] != "submit":
                        """
                        For all other actions besides submitting,
                        utilize miscellaneous information with special characters
                        """
                        data[input_tag["name"]] = f"test{j}"

                # Combine the URL with the action to form the request URL
                URL = urljoin(URL, form_details["action"])
                if form_details["method"] == "post":
                    res = session.post(URL, data=data)
                elif form_details["method"] == "get":
                    res = session.get(URL, params=data)

                """
                Test to determine if the resulting page,
                is susceptible to vulnerabilities
                """    
                if has_vulnerability(res):
                    print(Fore.RED + "[Obs!] SQL Injection vulnerability detected, link:", URL)
                    print(Fore.RED + "[•] Form:")
                    pprint(form_details)
                    log_vulnerability(URL, form_details)  # Log the URL and form details
                    break

    except Exception as e:
        print(Fore.RED + "An error occurred while scanning the URL:", e)

    # Stop the timer
    end_time = time.time()
    
    # Calculate the duration
    duration = end_time - start_time
    
    # Check if duration exceeds 60 seconds
    if duration > 60:
        duration_str = format_time(duration)
        print(Fore.GREEN + f"SQL Injection Scan completed in {duration_str}.")
    else:
        print(Fore.GREEN + f"SQL Injection Scan completed in {duration:.2f} seconds.")

#-------------------- Main Function --------------------

# This script prints a banner consisting of ASCII art and provides the Github URL.
if __name__ == "__main__":
    print(Fore.MAGENTA + "===========================================================================   ")
    print(Fore.CYAN + " ___       __   _______   ________                                               ")
    print(Fore.CYAN + "|\  \     |\  \|\  ___ \ |\   __  \                                              ")
    print(Fore.CYAN + "\ \  \    \ \  \ \   __/|\ \  \|\ /_                                             ")
    print(Fore.CYAN + " \ \  \  __\ \  \ \  \_|/_\ \   __  \                                            ")
    print(Fore.CYAN + "  \ \  \|\__\_\  \ \  \_|\ \ \  \|\  \                                           ")
    print(Fore.CYAN + "   \ \____________\ \_______\ \_______\                                          ")
    print(Fore.CYAN + " ___\|____________|\|_______|\|_______|   ________   _______   ________          ")
    print(Fore.CYAN + "|\   ____\|\   ____\|\   __  \|\   ___  \|\   ___  \|\  ___ \ |\   __  \         ")
    print(Fore.CYAN + "\ \  \___|\ \  \___|\ \  \|\  \ \  \\ \  \ \  \\ \  \ \   __/|\ \  \|\  \        ")
    print(Fore.CYAN + " \ \_____  \ \  \    \ \   __  \ \  \\ \  \ \  \\ \  \ \  \_|/_\ \   _  _\       ")
    print(Fore.CYAN + "  \|____|\  \ \  \____\ \  \ \  \ \  \\ \  \ \  \\ \  \ \  \_|\ \ \  \\  \|      ")
    print(Fore.CYAN + "    ____\_\  \ \_______\ \__\ \__\ \__\\ \__\ \__\\ \__\ \_______\ \__\\ _\      ")
    print(Fore.CYAN + "   |\_________\|_______|\|__|\|__|\|__| \|__|\|__| \|__|\|_______|\|__|\|__|     ")
    print(Fore.CYAN + "   \|_________|                                                                  ")
    print(Fore.CYAN + "                                                                                 ")
    print(Fore.CYAN + "                  Mattias_Sandberg & Elis_Gunnarsson                             ")
    print(Fore.CYAN + "                                                                                 ")
    print(Fore.CYAN + "        https://github.com/Mattias-Sandberg/Web-Vulnerability-Scanner            ")

                                                                                
    # This loop continuously prompts the user to select a preferred test for vulnerability scanning.
    while 1:
        print(Fore.MAGENTA + "===========================================================================")
        print(Fore.CYAN + "Select prefered Test ->")
        print(Fore.BLUE + "Type 1 : For CSS Vulnerability Scan")
        print(Fore.BLUE + "Type 2 : For SQLI Vulnerability Scan")
        print(Fore.RED + "Type 3 : Quit")
        print(Fore.MAGENTA + "===========================================================================")
        
        # After selecting an option, the user is prompted to provide a URL for the chosen vulnerability scan.
        number = eval(input(Fore.CYAN + "Enter a number to proceed -> "))

        # For CSS Scanning
        if number == 1:
            url = input(Fore.CYAN +"\nProvide the URL for CSS vulnerability scanning -> ")
            CSS_Scan(url)

        # For SQLI Scanning
        elif number == 2:
            url = input(Fore.CYAN + "\nProvide the URL for SQL Injection vulnerability scanning -> ")
            SQLI_Scan(url)
       
        # If the user chooses to quit, the program exits.
        elif number == 3:
            exit()
